## 回溯法（backtrack）

### 大家这么说的：

回溯法，是一种系统地搜索问题的方法。其算法思想有点类似于树的深度遍历。

在算法设计策略中，回溯法是比贪心法和动态规划更一般的方法。对于这样一类问题，其解可以表示成一个n-元组，求满足约束条件的可行解，或进一步求使目标函数取最大或最小值得最优解问题，其中许多问题都可以用回溯法求解。回溯法是一种通过搜索状态空间树来求问题的可行解或最优解的过程。回溯法使用约束函数和限界函数来压缩需要实际生产的状态空间树的节点数，从而大大节省问题求解时间。

回溯法的本质上是一种以深度优先方式，逐一生成状态空间树中节点并检测答案节点的方法。与穷举法不同，回溯法使用约束函数，剪去那些可以断定不含答案状态的子树，从而提高算法效率。

简单的理解就是：向下遍历，不含答案时，向上退回换路。

#### 算法框架
```
//一个保存最终结果的数组或容器，一般是vector，假设命名为 rvec
//一个保存临时单个结的数组或容器，一般也是vector,假设命名为 temp

void backtrack(.....) // 参数一般是包含源数组，最终结果数组，临时数组，以及你的目标，数组下标等
{
     if(条件) //看实际情况，有可能有条件也可能没有
        rvec保存这个结果;
     else
     {
        for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
        {
            if(条件)  //看实际情况，有可能有条件，也可能没有
            {
                temp.push_back(值）; //temp保存这个值
                backtrack(.....);  //主意看你是否可重复用数组元素，下标分别为原下标，或下边加一。
                temp.pop_back(); //回溯前的清理工作（如a[i]置空值等）;
            }
       }
    }
}
```



